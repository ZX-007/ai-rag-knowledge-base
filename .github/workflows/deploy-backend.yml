name: 部署后端到服务器

# 触发条件
on:
  # 推送 tag 时自动触发
  push:
    tags:
      - 'v*.*.*'  # 如 v1.0.0, v1.1.0, v2.0.0
  
  # 支持手动触发
  workflow_dispatch:
    inputs:
      tag_version:
        description: '镜像版本标签（如 v1.1.0）'
        required: true
        type: string
      environment:
        description: '部署环境'
        required: true
        type: choice
        options:
          - production
          - staging
        default: 'production'

env:
  DOCKER_IMAGE: white0618/ai-knowledge-base  # 替换为你的 Docker Hub 用户名/仓库名
  REGISTRY: docker.io

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: pro
    
    steps:
      # 步骤 1: 检出代码
      - name: 检出代码
        uses: actions/checkout@v4
      
      # 步骤 2: 设置 Java 环境
      - name: 设置 Java 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      
      # 步骤 3: 获取版本号
      - name: 获取版本号
        id: get_version
        run: |
          if [ "${{ github.event_name }}" == "push" ]; then
            # 从 tag 获取版本号
            VERSION=${GITHUB_REF#refs/tags/}
          else
            # 从手动输入获取版本号
            VERSION=${{ github.event.inputs.tag_version }}
          fi
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "📦 构建版本: ${VERSION}"
      
      # 步骤 4: 设置 Docker Buildx
      - name: 设置 Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      # 步骤 5: 登录 Docker Hub
      - name: 登录 Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      # 步骤 6: 构建并推送 Docker 镜像到 Docker Hub
      - name: 构建并推送 Docker 镜像
        id: docker_build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true  # 直接推送到 Docker Hub
          tags: |
            ${{ env.DOCKER_IMAGE }}:${{ steps.get_version.outputs.VERSION }}
            ${{ env.DOCKER_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      # 步骤 7: 备份和记录服务器上的当前版本
      - name: 备份当前版本和配置
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.BACKEND_SERVER_HOST }}
          username: ${{ secrets.BACKEND_SERVER_USERNAME }}
          key: ${{ secrets.BACKEND_SERVER_SSH_KEY }}
          port: ${{ secrets.BACKEND_SERVER_PORT || 22 }}
          script: |
            DEPLOY_DIR="${{ secrets.BACKEND_DEPLOY_DIR }}"
            IMAGE_NAME="${{ env.DOCKER_IMAGE }}"
            
            cd "${DEPLOY_DIR}"
            mkdir -p images
            
            # 记录当前版本
            if [ -f "docker-compose.yml" ]; then
              CURRENT_VERSION=$(grep "image: ${IMAGE_NAME}" docker-compose.yml | grep -oP '(?<=:)v[0-9]+\.[0-9]+\.[0-9]+' || echo "")
              if [ -n "$CURRENT_VERSION" ]; then
                echo "📝 记录当前运行版本: ${CURRENT_VERSION}"
                echo "${CURRENT_VERSION}" > .current_version
            
                # 备份当前配置文件
                cp docker-compose.yml docker-compose.yml.backup
                echo "💾 配置文件已备份"
            
                # 备份旧镜像（如果还没有备份）
                BACKUP_FILE="images/${IMAGE_NAME##*/}_${CURRENT_VERSION}.tar.gz"
                if [ ! -f "$BACKUP_FILE" ]; then
                  echo "💾 备份旧镜像 ${CURRENT_VERSION}..."
                  docker save ${IMAGE_NAME}:${CURRENT_VERSION} | gzip > $BACKUP_FILE 2>/dev/null || echo "  旧镜像已不存在，跳过备份"
                  if [ -f "$BACKUP_FILE" ]; then
                    echo "💾 备份大小: $(du -h $BACKUP_FILE | cut -f1)"
                  fi
                else
                  echo "  旧镜像备份已存在"
                fi
              else
                echo "ℹ️ 首次部署，无当前版本"
              fi
            else
              echo "ℹ️ docker-compose.yml 不存在，首次部署"
            fi
      
      # 步骤 8: 上传新的 docker-compose.yml
      - name: 上传 docker-compose.yml
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.BACKEND_SERVER_HOST }}
          username: ${{ secrets.BACKEND_SERVER_USERNAME }}
          key: ${{ secrets.BACKEND_SERVER_SSH_KEY }}
          port: ${{ secrets.BACKEND_SERVER_PORT || 22 }}
          source: "docker-compose.yml"
          target: ${{ secrets.BACKEND_DEPLOY_DIR }}
          strip_components: 0
          overwrite: true
      
      # 步骤 9: 在服务器上部署
      - name: 从 Docker Hub 拉取镜像并部署
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.BACKEND_SERVER_HOST }}
          username: ${{ secrets.BACKEND_SERVER_USERNAME }}
          key: ${{ secrets.BACKEND_SERVER_SSH_KEY }}
          port: ${{ secrets.BACKEND_SERVER_PORT || 22 }}
          script: |
            DEPLOY_DIR="${{ secrets.BACKEND_DEPLOY_DIR }}"
            VERSION="${{ steps.get_version.outputs.VERSION }}"
            IMAGE_NAME="${{ env.DOCKER_IMAGE }}"
            
            echo "=== 开始部署后端服务 ==="
            echo "部署目录: ${DEPLOY_DIR}"
            echo "镜像版本: ${VERSION}"
            echo "镜像地址: ${IMAGE_NAME}:${VERSION}"
            
            cd "${DEPLOY_DIR}"
            
            # 1. 从 Docker Hub 拉取新镜像
            echo "📥 从 Docker Hub 拉取新镜像: ${VERSION}..."
            echo "⏱️ 镜像拉取中，旧服务仍在运行，零停机时间..."
            docker pull ${IMAGE_NAME}:${VERSION}
            echo "✅ 镜像拉取完成"
            
            # 2. 停止旧服务
            if [ -f "docker-compose.yml.backup" ]; then
              echo "🛑 停止旧服务..."
              docker compose -f docker-compose.yml.backup down
            fi
            
            # 3. 更新 docker-compose.yml 中的镜像版本
            echo "🔧 更新 docker-compose.yml 镜像版本为: ${VERSION}"
            sed -i "s|image: ${IMAGE_NAME}:.*|image: ${IMAGE_NAME}:${VERSION}|g" docker-compose.yml
            
            # 4. 备份并更新 .env 文件（每次部署都更新）
            if [ -f ".env" ]; then
              cp .env .env.backup
              echo "💾 .env 文件已备份"
            fi
            echo "📝 更新 .env 文件..."
            echo "DASHSCOPE_API_KEY=${{ secrets.DASHSCOPE_API_KEY }}" > .env
            chmod 600 .env
            echo "✅ .env 文件已更新"
            
            # 5. 启动新版本服务
            echo "🚀 启动新版本服务..."
            docker compose up -d
            
            # 6. 等待服务启动
            echo "⏳ 等待服务启动..."
            sleep 10
            
            # 7. 检查服务状态
            echo "✅ 检查服务状态..."
            docker compose ps
            
            # 8. 查看服务日志
            echo ""
            echo "📋 服务日志:"
            docker compose logs --tail=12 ai-knowledge-base-app
            
            # 9. 健康检查（等待服务完全就绪）
            echo ""
            echo "🏥 健康检查..."
            
            # 检查容器是否运行
            if docker ps | grep -q ai-knowledge-base-app; then
              echo "✅ 容器运行正常"
            
              # 等待健康检查端点就绪（最多等待2分钟）
              MAX_RETRIES=60
              RETRY_COUNT=0
            
              echo "⏳ 等待健康检查端点就绪..."
              while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
                  # 获取健康状态
                  HEALTH_STATUS=$(curl -s http://localhost:8080/actuator/health | grep -o '"status":"[^"]*"' | head -1 | cut -d'"' -f4 || echo "UNKNOWN")
            
                  if [ "$HEALTH_STATUS" == "UP" ]; then
                    echo "✅ 健康检查通过: 状态 UP"
            
                    # 检查就绪探针
                    if curl -f http://localhost:8080/actuator/health/readiness > /dev/null 2>&1; then
                      echo "✅ Readiness 探针: 服务已就绪"
                    fi
            
                    # 检查存活探针
                    if curl -f http://localhost:8080/actuator/health/liveness > /dev/null 2>&1; then
                      echo "✅ Liveness 探针: 服务存活"
                    fi
            
                    break
                  else
                    echo "⚠️ 健康状态: $HEALTH_STATUS (等待中...)"
                  fi
                fi
            
                RETRY_COUNT=$((RETRY_COUNT + 1))
                sleep 2
              done
            
              if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                echo "❌ 健康检查超时（2分钟）"
                echo "查看容器日志："
                docker compose logs --tail=50 ai-knowledge-base-app
            
                # 触发回滚

                echo "🔄 开始自动回滚..."
            
                # 读取之前的版本
                if [ -f ".current_version" ]; then
                  ROLLBACK_VERSION=$(cat .current_version)
                  echo "回滚到版本: ${ROLLBACK_VERSION}"
            
                  # 停止失败的服务
                  docker compose down -v
            
                  # 恢复配置文件
                  if [ -f "docker-compose.yml.backup" ]; then
                    mv docker-compose.yml.backup docker-compose.yml
                    echo "✅ 配置文件已恢复"
                  fi
                  
                  # 恢复 .env 文件
                  if [ -f ".env.backup" ]; then
                    mv .env.backup .env
                    echo "✅ .env 文件已恢复"
                  fi
            
                  # 启动旧版本服务
                  docker compose up -d
            
                  # 等待并验证
                  sleep 10
                  if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
                    echo "✅ 回滚成功！服务已恢复到版本: ${ROLLBACK_VERSION}"
                  else
                    echo "❌ 回滚失败！请手动介入"
                  fi
                else
                  echo "⚠️ 无法回滚：没有找到之前的版本信息"
                fi
            
                exit 1
              fi
            else
              echo "❌ 容器未运行，触发回滚..."
            
              # 回滚逻辑
              if [ -f ".current_version" ] && [ -f "docker-compose.yml.backup" ]; then
                ROLLBACK_VERSION=$(cat .current_version)
                echo "🔄 回滚到版本: ${ROLLBACK_VERSION}"
            
                # 恢复配置文件
                mv docker-compose.yml.backup docker-compose.yml
                
                # 恢复 .env 文件
                if [ -f ".env.backup" ]; then
                  mv .env.backup .env
                fi
                
                docker compose up -d
            
                sleep 10
                if docker ps | grep -q ai-knowledge-base-app; then
                  echo "✅ 回滚成功！"
                else
                  echo "❌ 回滚失败！"
                fi
              fi
            
              exit 1
            fi
            
            # 9. 清理未使用的镜像（部署成功后）
            echo ""
            echo "🧹 清理未使用的旧镜像..."
            docker image prune -f
            
            # 10. 清理临时文件
            echo "🧹 清理临时备份文件..."
            rm -f .current_version docker-compose.yml.backup .env.backup
            
            echo ""
            echo "=== 部署完成！ ==="
            echo "镜像版本: ${IMAGE_NAME}:${VERSION}"
            echo "容器名称: ai-knowledge-base-app"
            echo "端口映射: 8080:8080"
            echo "✅ 新版本已成功部署并通过健康检查"
      
      # 步骤 10: 验证部署
      - name: 验证部署
        run: |
          echo "✅ 部署流程完成"
          echo "📦 镜像已推送到 Docker Hub: ${{ env.DOCKER_IMAGE }}:${{ steps.get_version.outputs.VERSION }}"
          echo "🚀 服务已在服务器上启动（从 Docker Hub 拉取）"
      
      # 步骤 11: 部署成功通知
      - name: 部署成功通知
        if: success()
        run: |
          echo "🎉 后端部署成功！"
          echo "版本: ${{ steps.get_version.outputs.VERSION }}"
          echo "镜像: ${{ env.DOCKER_IMAGE }}:${{ steps.get_version.outputs.VERSION }}"
          echo "镜像仓库: Docker Hub"
          echo "部署时间: $(date)"
      
      # 步骤 12: 部署失败通知
      - name: 部署失败通知
        if: failure()
        run: |
          echo "❌ 后端部署失败！"
          echo "请检查日志并修复问题"

